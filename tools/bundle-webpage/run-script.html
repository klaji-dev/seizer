<script>
const ERR = {
  SUCCESS: 0,
  BADF: 8,
  INVAL: 28,
  IO: 29,
};

const output_element = document.getElementById("output");
var windows = {};
var next_window_id = 4;

var gl_context = null;
var gl_shaders = {};
var gl_shaders_next_id = 4;
var gl_programs = {};
var gl_programs_next_id = 4;
var gl_textures = {};
var gl_textures_next_id = 4;
var gl_vertex_arrays = {};
var gl_vertex_arrays_next_id = 4;
var gl_buffers = {};
var gl_buffers_next_id = 4;
var gl_uniform_locations = {};
var gl_uniform_locations_next_id = 4;

var text_decoder = new TextDecoder();
var wasm_module = null;
var wasm_instance = null;
var stderr_buffer = "";
const importObject = {
  "wasi_snapshot_preview1": {
    "proc_exit": function (exit_code) {
      throw ("Main function exited with code " + exit_code);
    },
    "fd_write": function (fd, iovs_ptr, iovs_len, nwritten_ptr) {
      const data_view = new DataView(wasm_instance.exports.memory.buffer);
      var bytes_written = 0;
      if (fd == 2) {
        for (let i = 0; i < iovs_len; i += 1) {
          const iov_ptr = data_view.getUint32(iovs_ptr + i * 8, true);
          const iov_len = data_view.getUint32(iovs_ptr + i * 8 + 4, true);
          if (iov_ptr + iov_len > wasm_instance.exports.memory.buffer.byteLength) {
            return ERR.IO;
          }
          const iov = new Uint8Array(wasm_instance.exports.memory.buffer, iov_ptr, iov_len);
          bytes_written += iov_len;
          stderr_buffer = stderr_buffer + text_decoder.decode(iov);
        }
        console.log(stderr_buffer);
        stderr_buffer = "";
        data_view.setUint32(nwritten_ptr, bytes_written, true);
        return 0;
      }
      return ERR.SUCCESS;
    },
    "fd_read": function (fd, arg1, arg2, arg3) {
      console.log("fd_read(" + fd + ", " + arg1 + ", " + arg2 + ", " + arg3 + ")");
      return -1;
    },
    "fd_close": function (fd) {
      console.log("fd_close(" + fd + ")");
      return -1;
    },
    "path_open": function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
      console.log("path_open(" + arg0 + ", " + arg1 + ", " + arg2 + ", " + arg3 + ", " + arg4 + ", " + arg5 + ", " + arg6 + ", " + arg7 + ", " + arg8 + ")");
      return -1;
    },
    "fd_seek": function (fd) {
      throw "unimplemented";
    },
    "fd_filestat_get": function (fd) {
      throw "unimplemented";
    },
    clock_time_get: function(id, precision, timeOut) {
        if (id !== 0) return ERR.INVAL;

        const view = new DataView(wasm_instance.exports.memory.buffer);

        const now = new Date().getTime();

        view.setUint32(timeOut, (now * 1000000.0) % 0x100000000, true);
        view.setUint32(timeOut + 4, (now * 1000000.0) / 0x100000000, true);

        return ERR.SUCCESS;
    },
  },
  seizer: {
    create_surface: function(width, height) {
      window_id = next_window_id;
      next_window_id += 1;      

      const canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;

      output_element.append(canvas);

      windows[window_id] = {
        canvas: canvas,
        gl: canvas.getContext("webgl2"),
        should_close: false,
      };

      gl_context = windows[window_id].gl;

      return window_id;
    },
    surface_get_size: function(w_id, width_ptr, height_ptr) {
      const w = windows[w_id];

      const data_view = new DataView(wasm_instance.exports.memory.buffer);
      if (width_ptr) {
        data_view.setUint32(width_ptr, w.canvas.width, true);
      }
      if (height_ptr) {
        data_view.setUint32(height_ptr, w.canvas.height, true);
      }
    },
  },
  webgl2: {
    genTextures: function(textures_len, textures_ptr) {
      const textures_out = new Uint32Array(wasm_instance.exports.memory.buffer, textures_ptr, textures_len);
      for (let i = 0; i < textures_len; i += 1) {
        const texture_id = gl_textures_next_id;
        gl_textures_next_id += 1;

        gl_textures[texture_id] = gl_context.createTexture();

        textures_out[i] = texture_id;
      }
    },
    deleteTextures: function(textures_len, textures_ptr) {
      const textures = new Uint32Array(wasm_instance.exports.memory.buffer, textures_ptr, textures_len);
      for (let i = 0; i < textures_len; i += 1) {
        const texture_id = textures[i];
        gl_context.deleteTexture(gl_textures[texture_id]);
        delete gl_textures[texture_id];
      }
    },

    genBuffers: function(buffers_len, buffers_ptr) {
      const buffers_out = new Uint32Array(wasm_instance.exports.memory.buffer, buffers_ptr, buffers_len);
      for (let i = 0; i < buffers_len; i += 1) {
        const buffer_id = gl_buffers_next_id;
        gl_buffers_next_id += 1;

        gl_buffers[buffer_id] = gl_context.createBuffer();

        buffers_out[i] = buffer_id;
      }
    },
    deleteBuffers: function(buffers_len, buffers_ptr) {
      const buffers = new Uint32Array(wasm_instance.exports.memory.buffer, buffers_ptr, buffers_len);
      for (let i = 0; i < buffers_len; i += 1) {
        const buffer_id = buffers[i];
        gl_context.deleteBuffer(gl_buffers[buffer_id]);
        delete gl_buffers[buffer_id];
      }
    },

    genVertexArrays: function(vertex_arrays_len, vertex_arrays_ptr) {
      const vertex_arrays_out = new Uint32Array(wasm_instance.exports.memory.buffer, vertex_arrays_ptr, vertex_arrays_len);
      for (let i = 0; i < vertex_arrays_len; i += 1) {
        const vertex_array_id = gl_vertex_arrays_next_id;
        gl_vertex_arrays_next_id += 1;

        gl_vertex_arrays[vertex_array_id] = gl_context.createVertexArray();

        vertex_arrays_out[i] = vertex_array_id;
      }
    },
    createProgram: function() {
        const program_id = gl_programs_next_id;
        gl_programs_next_id += 1;
        gl_programs[program_id] = gl_context.createProgram();
        return program_id;
    },
    createShader: function(shader_type) {
        const shader_id = gl_shaders_next_id;
        gl_shaders_next_id += 1;
        gl_shaders[shader_id] = gl_context.createShader(shader_type);
        return shader_id;
    },

    // pub extern "webgl" fn texImage2D(target: Enum, level: Int, internalformat: Int, width: Sizei, height: Sizei, border: Int, format: Enum, @"type": Enum, pixels: ?*const anyopaque) void;
    texImage2D: function(target, level, internalformat, width, height, border, format, pixel_type, pixels_ptr) {
      const pixels = new Uint8Array(wasm_instance.exports.memory.buffer, pixels_ptr, width * height * 4);
      gl_context.texImage2D(target, level, internalformat, width, height, border, format, pixel_type, pixels);
    },

    // pub extern "webgl" fn bufferData(target: Enum, size: Sizeiptr, data: ?*const anyopaque, usage: Enum) void;
    bufferData: function(target, data_len, data_ptr, usage) {
      const data = new Uint8Array(wasm_instance.exports.memory.buffer, data_ptr, data_len);
      gl_context.bufferData(target, data, usage);
    },

    // pub extern "webgl" fn shaderSource(shader: Uint, count: Sizei, string: [*c]const [*c]const Char, length: [*c]const Int) void;
    shaderSource: function(shader_id, count, string_ptrs_ptr, string_lens_ptr) {
      const data_view = new DataView(wasm_instance.exports.memory.buffer);

      let shader_text = "";
      for (let i = 0; i < count; i += 1) {
        const string_ptr = data_view.getUint32(string_ptrs_ptr + i * 4, true);
        const string_len = data_view.getUint32(string_lens_ptr + i * 4, true);
        const string = text_decoder.decode(new Uint8Array(wasm_instance.exports.memory.buffer, string_ptr, string_len));
        shader_text = shader_text + string;
      }

      gl_context.shaderSource(gl_shaders[shader_id], shader_text);
    },

    // pub extern "webgl" fn getShaderiv(shader: Uint, pname: Enum, params: [*c]Int) void;
    getShaderiv: function(shader_id, pname, out_ptr) {
      if (pname === 0x8b84) return 0;
      const ret_value = gl_context.getShaderParameter(gl_shaders[shader_id], pname);

      const data_view = new DataView(wasm_instance.exports.memory.buffer);
      data_view.setUint32(out_ptr, ret_value, true);
    },
    // pub extern "webgl" fn getProgramiv(program: Uint, pname: Enum, params: [*c]Int) void;
    getProgramiv: function(program_id, pname, out_ptr) {
      // if (pname === 0x8b84) return 0;
      const ret_value = gl_context.getProgramParameter(gl_programs[program_id], pname);

      const data_view = new DataView(wasm_instance.exports.memory.buffer);
      data_view.setUint32(out_ptr, ret_value, true);
    },

    // pub extern "webgl" fn getShaderInfoLog(shader: Uint, bufSize: Sizei, length: [*c]Sizei, infoLog: [*c]Char) void;
    getShaderInfoLog: function(shader_id, buf_size, lens_ptr, info_log_ptr) { throw "getShaderInfoLog unimplemented"; },
    // pub extern "webgl" fn getProgramInfoLog(program: Uint, bufSize: Sizei, length: [*c]Sizei, infoLog: [*c]Char) void;
    getProgramInfoLog: function(program_id, buf_size, len_ptrs, info_log_ptrs) { throw "getProgramInfoLog unimplemented"; },

    // pub extern "webgl2" fn getUniformLocation(program: Uint, name: [*:0]const Char) void;
    getUniformLocation: function(program_id, name_ptr) {
      const data_view = new DataView(wasm_instance.exports.memory.buffer);
      let name_len = 0;
      for (;; name_len += 1) {
        if (data_view.getUint8(name_ptr + name_len, true) === 0) {
          break;
        }
      }

      const name = text_decoder.decode(new Uint8Array(wasm_instance.exports.memory.buffer, name_ptr, name_len));

      const uniform_location_id = gl_uniform_locations_next_id;
      gl_uniform_locations_next_id += 1;

      gl_uniform_locations[uniform_location_id] = gl_context.getUniformLocation(gl_programs[program_id], name);
      return uniform_location_id;
    },

    // pub extern "webgl2" fn uniformMatrix4fv(location: Int, count: Sizei, transpose: Boolean, value: [*c]const Float) void;
    uniformMatrix4fv: function(uniform_location_id, count, transpose, value_ptr) {
      const value = new Float32Array(wasm_instance.exports.memory.buffer, value_ptr, count * 16)
      // console.log(uniform_location_id, gl_uniform_locations[uniform_location_id]);
      gl_context.uniformMatrix4fv(gl_uniform_locations[uniform_location_id], transpose, value);
    },

    clearColor: function(red, green, blue, alpha) { gl_context.clearColor(red, green, blue, alpha); },
    clear: function(mask) { gl_context.clear(mask); },
    useProgram: function(program_id) { gl_context.useProgram(gl_programs[program_id]); },
    activeTexture: function(active_texture) { gl_context.activeTexture(active_texture); },
    bindTexture: function(target, texture_id) { gl_context.bindTexture(target, gl_textures[texture_id]); },
    bindVertexArray: function(array_id) { gl_context.bindVertexArray(gl_vertex_arrays[array_id]); },
    texParameteri: function(target, pname, param) { gl_context.texParameteri(target, pname, param); },
    compileShader: function(shader_id) { return gl_context.compileShader(gl_shaders[shader_id]); },
    deleteShader: function(shader_id) { return gl_context.deleteShader(gl_shaders[shader_id]); },
    attachShader: function(program_id, shader_id) { return gl_context.attachShader(gl_programs[program_id], gl_shaders[shader_id]); },
    linkProgram: function(program_id) { return gl_context.linkProgram(gl_programs[program_id]); },
    detachShader: function(program_id, shader_id) { return gl_context.detachShader(gl_programs[program_id], gl_shaders[shader_id]); },
    deleteProgram: function(program_id) { return gl_context.deleteProgram(gl_programs[program_id]); },
    enableVertexAttribArray: function(index) { return gl_context.enableVertexAttribArray(index); },
    bindBuffer: function(target, buffer_id) { return gl_context.bindBuffer(target, gl_buffers[buffer_id]); },
    vertexAttribPointer: function(index, size, type, normalized, stride, pointer) { return gl_context.vertexAttribPointer(index, size, type, normalized, stride, pointer); },
    drawArrays: function(mode, first, count) { return gl_context.drawArrays(mode, first, count); },
    enable: function(cap) { return gl_context.enable(cap); },
    disable: function(cap) { return gl_context.disable(cap); },
    blendFunc: function(sfactor, dfactor) { return gl_context.blendFunc(sfactor, dfactor); },
    scissor: function(x, y, width, height) { return gl_context.scissor(x, y, width, height); },
    uniform1i: function(uniform_location_id, v0) { return gl_context.uniform1i(gl_uniform_locations[uniform_location_id], v0); },
  },
};

function animationFrameCallback(timestamp) {
  if (wasm_instance) {
    wasm_instance.exports._render();
  }
  window.requestAnimationFrame(animationFrameCallback);
}

const z85_encoded_wasm_element = document.getElementById("z85-encoded-wasm");
const wasm_json = JSON.parse(z85_encoded_wasm_element.text);

const decoded_length = parseInt(z85_encoded_wasm_element.attributes["decoded-length"].value) ;
const wasm_binary = new Uint8Array(decoded_length);

z85_decode(wasm_json.data, wasm_binary);

WebAssembly.instantiate(wasm_binary, importObject).then(
  (results) => {
    wasm_module = results.module;
    wasm_instance = results.instance;
    wasm_instance.exports._initialize();
    window.requestAnimationFrame(animationFrameCallback);
  }
);
</script>
